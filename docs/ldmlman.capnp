@0xe0c33bb359ddae62; # Unique file ID generated by `capnp id`

# Note that any o- prefixed field indicates a memory-address offset.
# E.g: In the Rule struct, oAfter = offset within table to the 'after' field.

# Annotations

annotation len16(field) :Text; # Denotes the field name to contain this field's length.
annotation len8(field) :Text;  # Denotes the field name to contain this field's length.
annotation fixedLen(field) :UInt8; # Denotes a constant length for the field's List.
annotation if(field) :Text;

# Basic types
using FourCC = UInt32; # Denotes a four-character code in ASCII, compressed into a single 32-bit value.  
                       # TODO: Is FourCC Little-endian or Big-endian?
using Offset = UInt32; # Denotes an address offset for use in memory-mapped loads.
using Char = UInt32; # Denotes a UTF-32 character.
using BitFlags32 = UInt32;  # Denotes a set of bit flags representing multiple booleans.

struct String32 { # Denotes a UTF-32-based string.
    len @0 :UInt16;
    c @1 :List(Char);
}

# struct String8 { 
#     c @0 :List(UInt8);
#     z @1 :UInt8 = 0;
# }

# Directory
struct DirEntry {
    name @0 :FourCC;
    offset @1 :Offset;
    length @2 :UInt32;
    version @3 :UInt32;
}

struct Directory {
    entries @0 :List(DirEntry);
}

# Trie
struct Trie {
    type @0 :UInt8;
    reserved @1 :UInt8;
    numEntries @2 :UInt16;
    oResult @3 :Offset; # Offset to string, magic value (for string match success) or to rule (depending upon contextual use).
                     # 0 indicates transition node (no rule here)
    trieData :union {
        ordered @4 :List(OrderedTrie) $len16("numEntries");
        segmented @5 :List(SegmentedTrie) $len16("numEntries");
    }
}

struct OrderedTrie {
    c @0 :Char;
    o @1 :Offset; # Offset to next Trie node
}

struct SegmentedTrie {  # Run-length encoding style
    length @0 :UInt16; # Number of subsequent chars.
    c @1 :Char; # First char
    offsets @2 :List(Offset) $len16("length"); # Offset to next Trie node.
}

# Simple Transform
struct Rule {
    error @0 :Bool;
	oBefore @1 :Offset;
    oAfter @2 :Offset;  
	to @3 :String32;
    before @4 :Trie;
    after @5 :Trie;
}

struct Trns {
    settings @0 :UInt16;
    numRules @1 :UInt16;
	oOutputs @2 :Offset;
    t @3 :Trie;
    outputs @4 :List(Rule) $len16("numRules");
}

# Final Transform
struct Trnf {
    numRules @0 :UInt16;
	oOutputs @1 :Offset;
    t @2 :Trie;
    outputs @3 :List(Rule) $len16("numRules");
}

# Backspace Transform
struct Trnb {
    numRules @0 :UInt16;
	oOutputs @1 :Offset;
    t @2 :Trie;
    outputs @3 :List(Rule) $len16("numRules");
}

# Reorder
struct OrderRule {
    struct Info {
        prebase @0 :Bool;
        tertiaryBase @1 :Bool;
        order @2 :Int8;
    }
    error @0 :Bool;
    iLen @1 :UInt8;
	oAfter @2 :Offset;
    order @3 :List(Info) $len8("iLen");
    before @4 :Trie;
    after @5 :Trie;
}

struct Trnr {
    numRules @0 :UInt16;
	oOutputs @1 :Offset;
    t @2 :Trie;
    outputs @3 :List(OrderRule) $len16("numRules");
}

# KeyMaps
struct KeyMap {
    eModLen @0 :UInt8;
    modifiers @1 :UInt16;
    oEntries @2 :Offset;
    entriesLen @3 :UInt16;
    eModifiers @4 :Data $len8("eModLen");
    t @5 :Trie;
    entries @6 :List(KmapEntry) $len16("entriesLen");
}

struct KmapEntry {
    to @0 :String32;
    multiLen @1 :UInt8;
    oLong @2 :Offset;
    longLen @3 :UInt8;
    oFlick @4 :Offset;
    #hint: :String32; # If doing longpress hints, what string signals to a user that the key has longpress options?
    multiTap @5 :List(String32) $len8("multiLen");
    longPress @6 :List(String32) $len8("longLen");
    flicks @7 :List(String32) $fixedLen(8) $if("oFlick");
}

struct Kmap {
    klen @0 :UInt8;
    maps @1 :List(KeyMap);
}

struct Vkey {
    oVkey @0 :Offset;
    oMod @1 :Offset;
    iso @2 :String32;
    vkey @3 :String32;
    mod @4 :String32;
}

struct LayerKey {
    #width :UInt16; # or should it be Float32? # Denotes the width of a key.
    oIso @0 :Offset;
    oHint @1 :Offset;
    cap @2 :String32; # The displayed key cap.
    iso @3 :String32; # The represented key ISO code.
    hint @4 :String32; # The longpress hint, if it exists.
}

struct LayerRow {
    keysLen @0 :UInt8;
    keys @1 :List(LayerKey) $len8("keysLen");
}

struct LayerSwitch {
    oLayer @0 :Offset;
    oCap @1 :Offset;
    iso @2 :String32;
    layer @3 :String32;
    keycap @4 :String32;
}

struct Layer {
    modifier @0 :BitFlags32; # A set of bitflags corresponding to the modifier represented by the layer.
    rowsLen @1 :UInt8;
    switchesLen @2 :UInt8;
    vkeysLen @3 :UInt8;
    oSwitches @4 :Offset;
    oVkeys @5 :Offset;
    rows @6 :List(LayerRow) $len8("rowsLen");
    switches @7 :List(LayerSwitch) $len8("switchesLen");
    vkeys @8 :List(Vkey) $len8("vkeysLen");
}

struct Layr {
    llen @0 :UInt8; 
    layers @1 :List(Layer);
}

struct Name {
    lname @0 :UInt8;  # Assuming this 'name table length'
    nameLen @1 :UInt8;
    names @2 :List(String32) $len8("nameLen");
}

struct Head {
    ver @0 :String32;
}
