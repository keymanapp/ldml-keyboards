// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: ldmlman.capnp

#ifndef CAPNP_INCLUDED_e0c33bb359ddae62_
#define CAPNP_INCLUDED_e0c33bb359ddae62_

#include <capnp/generated-header-support.h>

#if CAPNP_VERSION != 6001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(c8bde6ffa981e5aa);
CAPNP_DECLARE_SCHEMA(b7080c3312e2b91f);
CAPNP_DECLARE_SCHEMA(e5c73126bc7d889d);
CAPNP_DECLARE_SCHEMA(88e64e2b35b6608d);
CAPNP_DECLARE_SCHEMA(af1e9cca9d4ab8f5);
CAPNP_DECLARE_SCHEMA(e30c6bc2d48f66b0);
CAPNP_DECLARE_SCHEMA(aa3a44db70e1c28e);
CAPNP_DECLARE_SCHEMA(83685f9995a34905);
CAPNP_DECLARE_SCHEMA(be9aeafc81950ef7);
CAPNP_DECLARE_SCHEMA(8861a67be6ece21d);
CAPNP_DECLARE_SCHEMA(9218de7b2671930f);
CAPNP_DECLARE_SCHEMA(c77587cf3e596ac0);
CAPNP_DECLARE_SCHEMA(f9cc17b1f69e366d);
CAPNP_DECLARE_SCHEMA(a34a7715b168aec7);
CAPNP_DECLARE_SCHEMA(bea9deb94542d934);
CAPNP_DECLARE_SCHEMA(8511099f2a172cff);
CAPNP_DECLARE_SCHEMA(f7f9494e1d577e60);
CAPNP_DECLARE_SCHEMA(a2ee677060644ee3);
CAPNP_DECLARE_SCHEMA(cf8ac8460d2a8128);
CAPNP_DECLARE_SCHEMA(e3ac895748951c29);
CAPNP_DECLARE_SCHEMA(bdf63db644680692);
CAPNP_DECLARE_SCHEMA(dc0ee6af6421b4f9);
CAPNP_DECLARE_SCHEMA(9dfa2ae57c411127);
CAPNP_DECLARE_SCHEMA(b3806eed4e111eff);
CAPNP_DECLARE_SCHEMA(bd711101bf1bf089);
CAPNP_DECLARE_SCHEMA(835ad07fa2b5ccf1);
CAPNP_DECLARE_SCHEMA(fcee253fd93711f3);
CAPNP_DECLARE_SCHEMA(bf628ef7b22e3423);
CAPNP_DECLARE_SCHEMA(cc5b28b8f92c628a);
CAPNP_DECLARE_SCHEMA(fe504fdeae7620f1);
CAPNP_DECLARE_SCHEMA(e39d29ddb34692d8);
CAPNP_DECLARE_SCHEMA(ef4acc83100f7c37);

}  // namespace schemas
}  // namespace capnp


struct String32 {
  String32() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(af1e9cca9d4ab8f5, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct DirEntry {
  DirEntry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e30c6bc2d48f66b0, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Directory {
  Directory() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aa3a44db70e1c28e, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Trie {
  Trie() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct TrieData;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(be9aeafc81950ef7, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Trie::TrieData {
  TrieData() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    ORDERED,
    SEGMENTED,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8861a67be6ece21d, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct OrderedTrie {
  OrderedTrie() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9218de7b2671930f, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SegmentedTrie {
  SegmentedTrie() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c77587cf3e596ac0, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Rule {
  Rule() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f9cc17b1f69e366d, 2, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Trns {
  Trns() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a34a7715b168aec7, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Trnf {
  Trnf() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bea9deb94542d934, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Trnb {
  Trnb() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8511099f2a172cff, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct OrderRule {
  OrderRule() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Info;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f7f9494e1d577e60, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct OrderRule::Info {
  Info() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a2ee677060644ee3, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Trnr {
  Trnr() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cf8ac8460d2a8128, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct KeyMap {
  KeyMap() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e3ac895748951c29, 2, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct KmapEntry {
  KmapEntry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bdf63db644680692, 2, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Kmap {
  Kmap() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dc0ee6af6421b4f9, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LayerKey {
  LayerKey() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9dfa2ae57c411127, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LayerRow {
  LayerRow() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b3806eed4e111eff, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LayerSwitch {
  LayerSwitch() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bd711101bf1bf089, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Layer {
  Layer() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(835ad07fa2b5ccf1, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Layr {
  Layr() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fcee253fd93711f3, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Name {
  Name() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bf628ef7b22e3423, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Head {
  Head() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cc5b28b8f92c628a, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VkeyEntry {
  VkeyEntry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe504fdeae7620f1, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PlatformVkeys {
  PlatformVkeys() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e39d29ddb34692d8, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vkey {
  Vkey() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ef4acc83100f7c37, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class String32::Reader {
public:
  typedef String32 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getLen() const;

  inline bool hasC() const;
  inline  ::capnp::List< ::uint32_t>::Reader getC() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class String32::Builder {
public:
  typedef String32 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getLen();
  inline void setLen( ::uint16_t value);

  inline bool hasC();
  inline  ::capnp::List< ::uint32_t>::Builder getC();
  inline void setC( ::capnp::List< ::uint32_t>::Reader value);
  inline void setC(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t>::Builder initC(unsigned int size);
  inline void adoptC(::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> disownC();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class String32::Pipeline {
public:
  typedef String32 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DirEntry::Reader {
public:
  typedef DirEntry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getName() const;

  inline  ::uint32_t getOffset() const;

  inline  ::uint32_t getLength() const;

  inline  ::uint32_t getVersion() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DirEntry::Builder {
public:
  typedef DirEntry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getName();
  inline void setName( ::uint32_t value);

  inline  ::uint32_t getOffset();
  inline void setOffset( ::uint32_t value);

  inline  ::uint32_t getLength();
  inline void setLength( ::uint32_t value);

  inline  ::uint32_t getVersion();
  inline void setVersion( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DirEntry::Pipeline {
public:
  typedef DirEntry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Directory::Reader {
public:
  typedef Directory Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEntries() const;
  inline  ::capnp::List< ::DirEntry>::Reader getEntries() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Directory::Builder {
public:
  typedef Directory Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEntries();
  inline  ::capnp::List< ::DirEntry>::Builder getEntries();
  inline void setEntries( ::capnp::List< ::DirEntry>::Reader value);
  inline  ::capnp::List< ::DirEntry>::Builder initEntries(unsigned int size);
  inline void adoptEntries(::capnp::Orphan< ::capnp::List< ::DirEntry>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::DirEntry>> disownEntries();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Directory::Pipeline {
public:
  typedef Directory Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Trie::Reader {
public:
  typedef Trie Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType() const;

  inline  ::uint8_t getReserved() const;

  inline  ::uint16_t getNumEntries() const;

  inline  ::uint32_t getResult() const;

  inline typename TrieData::Reader getTrieData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Trie::Builder {
public:
  typedef Trie Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline  ::uint8_t getReserved();
  inline void setReserved( ::uint8_t value);

  inline  ::uint16_t getNumEntries();
  inline void setNumEntries( ::uint16_t value);

  inline  ::uint32_t getResult();
  inline void setResult( ::uint32_t value);

  inline typename TrieData::Builder getTrieData();
  inline typename TrieData::Builder initTrieData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Trie::Pipeline {
public:
  typedef Trie Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename TrieData::Pipeline getTrieData();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Trie::TrieData::Reader {
public:
  typedef TrieData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isOrdered() const;
  inline bool hasOrdered() const;
  inline  ::capnp::List< ::OrderedTrie>::Reader getOrdered() const;

  inline bool isSegmented() const;
  inline bool hasSegmented() const;
  inline  ::capnp::List< ::SegmentedTrie>::Reader getSegmented() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Trie::TrieData::Builder {
public:
  typedef TrieData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isOrdered();
  inline bool hasOrdered();
  inline  ::capnp::List< ::OrderedTrie>::Builder getOrdered();
  inline void setOrdered( ::capnp::List< ::OrderedTrie>::Reader value);
  inline  ::capnp::List< ::OrderedTrie>::Builder initOrdered(unsigned int size);
  inline void adoptOrdered(::capnp::Orphan< ::capnp::List< ::OrderedTrie>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::OrderedTrie>> disownOrdered();

  inline bool isSegmented();
  inline bool hasSegmented();
  inline  ::capnp::List< ::SegmentedTrie>::Builder getSegmented();
  inline void setSegmented( ::capnp::List< ::SegmentedTrie>::Reader value);
  inline  ::capnp::List< ::SegmentedTrie>::Builder initSegmented(unsigned int size);
  inline void adoptSegmented(::capnp::Orphan< ::capnp::List< ::SegmentedTrie>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::SegmentedTrie>> disownSegmented();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Trie::TrieData::Pipeline {
public:
  typedef TrieData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class OrderedTrie::Reader {
public:
  typedef OrderedTrie Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getC() const;

  inline  ::uint32_t getO() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class OrderedTrie::Builder {
public:
  typedef OrderedTrie Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getC();
  inline void setC( ::uint32_t value);

  inline  ::uint32_t getO();
  inline void setO( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class OrderedTrie::Pipeline {
public:
  typedef OrderedTrie Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SegmentedTrie::Reader {
public:
  typedef SegmentedTrie Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getC() const;

  inline bool hasOffsets() const;
  inline  ::capnp::List< ::uint32_t>::Reader getOffsets() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SegmentedTrie::Builder {
public:
  typedef SegmentedTrie Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getC();
  inline void setC( ::uint32_t value);

  inline bool hasOffsets();
  inline  ::capnp::List< ::uint32_t>::Builder getOffsets();
  inline void setOffsets( ::capnp::List< ::uint32_t>::Reader value);
  inline void setOffsets(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t>::Builder initOffsets(unsigned int size);
  inline void adoptOffsets(::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> disownOffsets();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SegmentedTrie::Pipeline {
public:
  typedef SegmentedTrie Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Rule::Reader {
public:
  typedef Rule Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getError() const;

  inline  ::uint32_t getOBefore() const;

  inline  ::uint32_t getOAfter() const;

  inline bool hasTo() const;
  inline  ::String32::Reader getTo() const;

  inline bool hasBefore() const;
  inline  ::Trie::Reader getBefore() const;

  inline bool hasAfter() const;
  inline  ::Trie::Reader getAfter() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Rule::Builder {
public:
  typedef Rule Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getError();
  inline void setError(bool value);

  inline  ::uint32_t getOBefore();
  inline void setOBefore( ::uint32_t value);

  inline  ::uint32_t getOAfter();
  inline void setOAfter( ::uint32_t value);

  inline bool hasTo();
  inline  ::String32::Builder getTo();
  inline void setTo( ::String32::Reader value);
  inline  ::String32::Builder initTo();
  inline void adoptTo(::capnp::Orphan< ::String32>&& value);
  inline ::capnp::Orphan< ::String32> disownTo();

  inline bool hasBefore();
  inline  ::Trie::Builder getBefore();
  inline void setBefore( ::Trie::Reader value);
  inline  ::Trie::Builder initBefore();
  inline void adoptBefore(::capnp::Orphan< ::Trie>&& value);
  inline ::capnp::Orphan< ::Trie> disownBefore();

  inline bool hasAfter();
  inline  ::Trie::Builder getAfter();
  inline void setAfter( ::Trie::Reader value);
  inline  ::Trie::Builder initAfter();
  inline void adoptAfter(::capnp::Orphan< ::Trie>&& value);
  inline ::capnp::Orphan< ::Trie> disownAfter();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Rule::Pipeline {
public:
  typedef Rule Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::String32::Pipeline getTo();
  inline  ::Trie::Pipeline getBefore();
  inline  ::Trie::Pipeline getAfter();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Trns::Reader {
public:
  typedef Trns Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getSettings() const;

  inline  ::uint16_t getNumRules() const;

  inline  ::uint32_t getOOutputs() const;

  inline bool hasT() const;
  inline  ::Trie::Reader getT() const;

  inline bool hasOutputs() const;
  inline  ::capnp::List< ::Rule>::Reader getOutputs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Trns::Builder {
public:
  typedef Trns Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getSettings();
  inline void setSettings( ::uint16_t value);

  inline  ::uint16_t getNumRules();
  inline void setNumRules( ::uint16_t value);

  inline  ::uint32_t getOOutputs();
  inline void setOOutputs( ::uint32_t value);

  inline bool hasT();
  inline  ::Trie::Builder getT();
  inline void setT( ::Trie::Reader value);
  inline  ::Trie::Builder initT();
  inline void adoptT(::capnp::Orphan< ::Trie>&& value);
  inline ::capnp::Orphan< ::Trie> disownT();

  inline bool hasOutputs();
  inline  ::capnp::List< ::Rule>::Builder getOutputs();
  inline void setOutputs( ::capnp::List< ::Rule>::Reader value);
  inline  ::capnp::List< ::Rule>::Builder initOutputs(unsigned int size);
  inline void adoptOutputs(::capnp::Orphan< ::capnp::List< ::Rule>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Rule>> disownOutputs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Trns::Pipeline {
public:
  typedef Trns Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Trie::Pipeline getT();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Trnf::Reader {
public:
  typedef Trnf Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getNumRules() const;

  inline  ::uint32_t getOOutputs() const;

  inline bool hasT() const;
  inline  ::Trie::Reader getT() const;

  inline bool hasOutputs() const;
  inline  ::capnp::List< ::Rule>::Reader getOutputs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Trnf::Builder {
public:
  typedef Trnf Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getNumRules();
  inline void setNumRules( ::uint16_t value);

  inline  ::uint32_t getOOutputs();
  inline void setOOutputs( ::uint32_t value);

  inline bool hasT();
  inline  ::Trie::Builder getT();
  inline void setT( ::Trie::Reader value);
  inline  ::Trie::Builder initT();
  inline void adoptT(::capnp::Orphan< ::Trie>&& value);
  inline ::capnp::Orphan< ::Trie> disownT();

  inline bool hasOutputs();
  inline  ::capnp::List< ::Rule>::Builder getOutputs();
  inline void setOutputs( ::capnp::List< ::Rule>::Reader value);
  inline  ::capnp::List< ::Rule>::Builder initOutputs(unsigned int size);
  inline void adoptOutputs(::capnp::Orphan< ::capnp::List< ::Rule>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Rule>> disownOutputs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Trnf::Pipeline {
public:
  typedef Trnf Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Trie::Pipeline getT();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Trnb::Reader {
public:
  typedef Trnb Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getNumRules() const;

  inline  ::uint32_t getOOutputs() const;

  inline bool hasT() const;
  inline  ::Trie::Reader getT() const;

  inline bool hasOutputs() const;
  inline  ::capnp::List< ::Rule>::Reader getOutputs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Trnb::Builder {
public:
  typedef Trnb Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getNumRules();
  inline void setNumRules( ::uint16_t value);

  inline  ::uint32_t getOOutputs();
  inline void setOOutputs( ::uint32_t value);

  inline bool hasT();
  inline  ::Trie::Builder getT();
  inline void setT( ::Trie::Reader value);
  inline  ::Trie::Builder initT();
  inline void adoptT(::capnp::Orphan< ::Trie>&& value);
  inline ::capnp::Orphan< ::Trie> disownT();

  inline bool hasOutputs();
  inline  ::capnp::List< ::Rule>::Builder getOutputs();
  inline void setOutputs( ::capnp::List< ::Rule>::Reader value);
  inline  ::capnp::List< ::Rule>::Builder initOutputs(unsigned int size);
  inline void adoptOutputs(::capnp::Orphan< ::capnp::List< ::Rule>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Rule>> disownOutputs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Trnb::Pipeline {
public:
  typedef Trnb Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Trie::Pipeline getT();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class OrderRule::Reader {
public:
  typedef OrderRule Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getError() const;

  inline  ::uint8_t getILen() const;

  inline  ::uint32_t getOAfter() const;

  inline bool hasOrder() const;
  inline  ::capnp::List< ::OrderRule::Info>::Reader getOrder() const;

  inline bool hasBefore() const;
  inline  ::Trie::Reader getBefore() const;

  inline bool hasAfter() const;
  inline  ::Trie::Reader getAfter() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class OrderRule::Builder {
public:
  typedef OrderRule Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getError();
  inline void setError(bool value);

  inline  ::uint8_t getILen();
  inline void setILen( ::uint8_t value);

  inline  ::uint32_t getOAfter();
  inline void setOAfter( ::uint32_t value);

  inline bool hasOrder();
  inline  ::capnp::List< ::OrderRule::Info>::Builder getOrder();
  inline void setOrder( ::capnp::List< ::OrderRule::Info>::Reader value);
  inline  ::capnp::List< ::OrderRule::Info>::Builder initOrder(unsigned int size);
  inline void adoptOrder(::capnp::Orphan< ::capnp::List< ::OrderRule::Info>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::OrderRule::Info>> disownOrder();

  inline bool hasBefore();
  inline  ::Trie::Builder getBefore();
  inline void setBefore( ::Trie::Reader value);
  inline  ::Trie::Builder initBefore();
  inline void adoptBefore(::capnp::Orphan< ::Trie>&& value);
  inline ::capnp::Orphan< ::Trie> disownBefore();

  inline bool hasAfter();
  inline  ::Trie::Builder getAfter();
  inline void setAfter( ::Trie::Reader value);
  inline  ::Trie::Builder initAfter();
  inline void adoptAfter(::capnp::Orphan< ::Trie>&& value);
  inline ::capnp::Orphan< ::Trie> disownAfter();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class OrderRule::Pipeline {
public:
  typedef OrderRule Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Trie::Pipeline getBefore();
  inline  ::Trie::Pipeline getAfter();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class OrderRule::Info::Reader {
public:
  typedef Info Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getPrebase() const;

  inline bool getTertiaryBase() const;

  inline  ::int8_t getOrder() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class OrderRule::Info::Builder {
public:
  typedef Info Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getPrebase();
  inline void setPrebase(bool value);

  inline bool getTertiaryBase();
  inline void setTertiaryBase(bool value);

  inline  ::int8_t getOrder();
  inline void setOrder( ::int8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class OrderRule::Info::Pipeline {
public:
  typedef Info Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Trnr::Reader {
public:
  typedef Trnr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getNumRules() const;

  inline  ::uint32_t getOOutputs() const;

  inline bool hasT() const;
  inline  ::Trie::Reader getT() const;

  inline bool hasOutputs() const;
  inline  ::capnp::List< ::OrderRule>::Reader getOutputs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Trnr::Builder {
public:
  typedef Trnr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getNumRules();
  inline void setNumRules( ::uint16_t value);

  inline  ::uint32_t getOOutputs();
  inline void setOOutputs( ::uint32_t value);

  inline bool hasT();
  inline  ::Trie::Builder getT();
  inline void setT( ::Trie::Reader value);
  inline  ::Trie::Builder initT();
  inline void adoptT(::capnp::Orphan< ::Trie>&& value);
  inline ::capnp::Orphan< ::Trie> disownT();

  inline bool hasOutputs();
  inline  ::capnp::List< ::OrderRule>::Builder getOutputs();
  inline void setOutputs( ::capnp::List< ::OrderRule>::Reader value);
  inline  ::capnp::List< ::OrderRule>::Builder initOutputs(unsigned int size);
  inline void adoptOutputs(::capnp::Orphan< ::capnp::List< ::OrderRule>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::OrderRule>> disownOutputs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Trnr::Pipeline {
public:
  typedef Trnr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Trie::Pipeline getT();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class KeyMap::Reader {
public:
  typedef KeyMap Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getEModLen() const;

  inline  ::uint16_t getModifiers() const;

  inline  ::uint32_t getOEntries() const;

  inline  ::uint16_t getEntriesLen() const;

  inline bool hasEModifiers() const;
  inline  ::capnp::Data::Reader getEModifiers() const;

  inline bool hasT() const;
  inline  ::Trie::Reader getT() const;

  inline bool hasEntries() const;
  inline  ::capnp::List< ::KmapEntry>::Reader getEntries() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class KeyMap::Builder {
public:
  typedef KeyMap Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getEModLen();
  inline void setEModLen( ::uint8_t value);

  inline  ::uint16_t getModifiers();
  inline void setModifiers( ::uint16_t value);

  inline  ::uint32_t getOEntries();
  inline void setOEntries( ::uint32_t value);

  inline  ::uint16_t getEntriesLen();
  inline void setEntriesLen( ::uint16_t value);

  inline bool hasEModifiers();
  inline  ::capnp::Data::Builder getEModifiers();
  inline void setEModifiers( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initEModifiers(unsigned int size);
  inline void adoptEModifiers(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownEModifiers();

  inline bool hasT();
  inline  ::Trie::Builder getT();
  inline void setT( ::Trie::Reader value);
  inline  ::Trie::Builder initT();
  inline void adoptT(::capnp::Orphan< ::Trie>&& value);
  inline ::capnp::Orphan< ::Trie> disownT();

  inline bool hasEntries();
  inline  ::capnp::List< ::KmapEntry>::Builder getEntries();
  inline void setEntries( ::capnp::List< ::KmapEntry>::Reader value);
  inline  ::capnp::List< ::KmapEntry>::Builder initEntries(unsigned int size);
  inline void adoptEntries(::capnp::Orphan< ::capnp::List< ::KmapEntry>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::KmapEntry>> disownEntries();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class KeyMap::Pipeline {
public:
  typedef KeyMap Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Trie::Pipeline getT();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class KmapEntry::Reader {
public:
  typedef KmapEntry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTo() const;
  inline  ::String32::Reader getTo() const;

  inline  ::uint8_t getMultiLen() const;

  inline  ::uint32_t getOLong() const;

  inline  ::uint8_t getLongLen() const;

  inline  ::uint32_t getOFlick() const;

  inline bool hasMultiTap() const;
  inline  ::capnp::List< ::String32>::Reader getMultiTap() const;

  inline bool hasLongPress() const;
  inline  ::capnp::List< ::String32>::Reader getLongPress() const;

  inline bool hasFlicks() const;
  inline  ::capnp::List< ::String32>::Reader getFlicks() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class KmapEntry::Builder {
public:
  typedef KmapEntry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTo();
  inline  ::String32::Builder getTo();
  inline void setTo( ::String32::Reader value);
  inline  ::String32::Builder initTo();
  inline void adoptTo(::capnp::Orphan< ::String32>&& value);
  inline ::capnp::Orphan< ::String32> disownTo();

  inline  ::uint8_t getMultiLen();
  inline void setMultiLen( ::uint8_t value);

  inline  ::uint32_t getOLong();
  inline void setOLong( ::uint32_t value);

  inline  ::uint8_t getLongLen();
  inline void setLongLen( ::uint8_t value);

  inline  ::uint32_t getOFlick();
  inline void setOFlick( ::uint32_t value);

  inline bool hasMultiTap();
  inline  ::capnp::List< ::String32>::Builder getMultiTap();
  inline void setMultiTap( ::capnp::List< ::String32>::Reader value);
  inline  ::capnp::List< ::String32>::Builder initMultiTap(unsigned int size);
  inline void adoptMultiTap(::capnp::Orphan< ::capnp::List< ::String32>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::String32>> disownMultiTap();

  inline bool hasLongPress();
  inline  ::capnp::List< ::String32>::Builder getLongPress();
  inline void setLongPress( ::capnp::List< ::String32>::Reader value);
  inline  ::capnp::List< ::String32>::Builder initLongPress(unsigned int size);
  inline void adoptLongPress(::capnp::Orphan< ::capnp::List< ::String32>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::String32>> disownLongPress();

  inline bool hasFlicks();
  inline  ::capnp::List< ::String32>::Builder getFlicks();
  inline void setFlicks( ::capnp::List< ::String32>::Reader value);
  inline  ::capnp::List< ::String32>::Builder initFlicks(unsigned int size);
  inline void adoptFlicks(::capnp::Orphan< ::capnp::List< ::String32>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::String32>> disownFlicks();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class KmapEntry::Pipeline {
public:
  typedef KmapEntry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::String32::Pipeline getTo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Kmap::Reader {
public:
  typedef Kmap Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasMaps() const;
  inline  ::capnp::List< ::KeyMap>::Reader getMaps() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Kmap::Builder {
public:
  typedef Kmap Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMaps();
  inline  ::capnp::List< ::KeyMap>::Builder getMaps();
  inline void setMaps( ::capnp::List< ::KeyMap>::Reader value);
  inline  ::capnp::List< ::KeyMap>::Builder initMaps(unsigned int size);
  inline void adoptMaps(::capnp::Orphan< ::capnp::List< ::KeyMap>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::KeyMap>> disownMaps();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Kmap::Pipeline {
public:
  typedef Kmap Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LayerKey::Reader {
public:
  typedef LayerKey Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getIso() const;

  inline  ::uint32_t getOHint() const;

  inline bool hasCap() const;
  inline  ::String32::Reader getCap() const;

  inline bool hasHint() const;
  inline  ::String32::Reader getHint() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LayerKey::Builder {
public:
  typedef LayerKey Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getIso();
  inline void setIso( ::uint32_t value);

  inline  ::uint32_t getOHint();
  inline void setOHint( ::uint32_t value);

  inline bool hasCap();
  inline  ::String32::Builder getCap();
  inline void setCap( ::String32::Reader value);
  inline  ::String32::Builder initCap();
  inline void adoptCap(::capnp::Orphan< ::String32>&& value);
  inline ::capnp::Orphan< ::String32> disownCap();

  inline bool hasHint();
  inline  ::String32::Builder getHint();
  inline void setHint( ::String32::Reader value);
  inline  ::String32::Builder initHint();
  inline void adoptHint(::capnp::Orphan< ::String32>&& value);
  inline ::capnp::Orphan< ::String32> disownHint();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LayerKey::Pipeline {
public:
  typedef LayerKey Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::String32::Pipeline getCap();
  inline  ::String32::Pipeline getHint();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LayerRow::Reader {
public:
  typedef LayerRow Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKeys() const;
  inline  ::capnp::List< ::LayerKey>::Reader getKeys() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LayerRow::Builder {
public:
  typedef LayerRow Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKeys();
  inline  ::capnp::List< ::LayerKey>::Builder getKeys();
  inline void setKeys( ::capnp::List< ::LayerKey>::Reader value);
  inline  ::capnp::List< ::LayerKey>::Builder initKeys(unsigned int size);
  inline void adoptKeys(::capnp::Orphan< ::capnp::List< ::LayerKey>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::LayerKey>> disownKeys();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LayerRow::Pipeline {
public:
  typedef LayerRow Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LayerSwitch::Reader {
public:
  typedef LayerSwitch Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getOLayer() const;

  inline  ::uint32_t getIso() const;

  inline bool hasLayer() const;
  inline  ::String32::Reader getLayer() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LayerSwitch::Builder {
public:
  typedef LayerSwitch Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getOLayer();
  inline void setOLayer( ::uint32_t value);

  inline  ::uint32_t getIso();
  inline void setIso( ::uint32_t value);

  inline bool hasLayer();
  inline  ::String32::Builder getLayer();
  inline void setLayer( ::String32::Reader value);
  inline  ::String32::Builder initLayer();
  inline void adoptLayer(::capnp::Orphan< ::String32>&& value);
  inline ::capnp::Orphan< ::String32> disownLayer();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LayerSwitch::Pipeline {
public:
  typedef LayerSwitch Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::String32::Pipeline getLayer();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Layer::Reader {
public:
  typedef Layer Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getModifier() const;

  inline  ::uint8_t getRowsLen() const;

  inline  ::uint8_t getSwitchesLen() const;

  inline  ::uint8_t getVkeysLen() const;

  inline  ::uint32_t getOSwitches() const;

  inline bool hasRows() const;
  inline  ::capnp::List< ::LayerRow>::Reader getRows() const;

  inline bool hasSwitches() const;
  inline  ::capnp::List< ::LayerSwitch>::Reader getSwitches() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Layer::Builder {
public:
  typedef Layer Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getModifier();
  inline void setModifier( ::uint16_t value);

  inline  ::uint8_t getRowsLen();
  inline void setRowsLen( ::uint8_t value);

  inline  ::uint8_t getSwitchesLen();
  inline void setSwitchesLen( ::uint8_t value);

  inline  ::uint8_t getVkeysLen();
  inline void setVkeysLen( ::uint8_t value);

  inline  ::uint32_t getOSwitches();
  inline void setOSwitches( ::uint32_t value);

  inline bool hasRows();
  inline  ::capnp::List< ::LayerRow>::Builder getRows();
  inline void setRows( ::capnp::List< ::LayerRow>::Reader value);
  inline  ::capnp::List< ::LayerRow>::Builder initRows(unsigned int size);
  inline void adoptRows(::capnp::Orphan< ::capnp::List< ::LayerRow>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::LayerRow>> disownRows();

  inline bool hasSwitches();
  inline  ::capnp::List< ::LayerSwitch>::Builder getSwitches();
  inline void setSwitches( ::capnp::List< ::LayerSwitch>::Reader value);
  inline  ::capnp::List< ::LayerSwitch>::Builder initSwitches(unsigned int size);
  inline void adoptSwitches(::capnp::Orphan< ::capnp::List< ::LayerSwitch>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::LayerSwitch>> disownSwitches();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Layer::Pipeline {
public:
  typedef Layer Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Layr::Reader {
public:
  typedef Layr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLayers() const;
  inline  ::capnp::List< ::Layer>::Reader getLayers() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Layr::Builder {
public:
  typedef Layr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLayers();
  inline  ::capnp::List< ::Layer>::Builder getLayers();
  inline void setLayers( ::capnp::List< ::Layer>::Reader value);
  inline  ::capnp::List< ::Layer>::Builder initLayers(unsigned int size);
  inline void adoptLayers(::capnp::Orphan< ::capnp::List< ::Layer>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Layer>> disownLayers();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Layr::Pipeline {
public:
  typedef Layr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Name::Reader {
public:
  typedef Name Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasNames() const;
  inline  ::capnp::List< ::String32>::Reader getNames() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Name::Builder {
public:
  typedef Name Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasNames();
  inline  ::capnp::List< ::String32>::Builder getNames();
  inline void setNames( ::capnp::List< ::String32>::Reader value);
  inline  ::capnp::List< ::String32>::Builder initNames(unsigned int size);
  inline void adoptNames(::capnp::Orphan< ::capnp::List< ::String32>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::String32>> disownNames();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Name::Pipeline {
public:
  typedef Name Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Head::Reader {
public:
  typedef Head Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasVer() const;
  inline  ::String32::Reader getVer() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Head::Builder {
public:
  typedef Head Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasVer();
  inline  ::String32::Builder getVer();
  inline void setVer( ::String32::Reader value);
  inline  ::String32::Builder initVer();
  inline void adoptVer(::capnp::Orphan< ::String32>&& value);
  inline ::capnp::Orphan< ::String32> disownVer();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Head::Pipeline {
public:
  typedef Head Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::String32::Pipeline getVer();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VkeyEntry::Reader {
public:
  typedef VkeyEntry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getVkeyCode() const;

  inline  ::uint16_t getModifiers() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VkeyEntry::Builder {
public:
  typedef VkeyEntry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getVkeyCode();
  inline void setVkeyCode( ::uint16_t value);

  inline  ::uint16_t getModifiers();
  inline void setModifiers( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VkeyEntry::Pipeline {
public:
  typedef VkeyEntry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PlatformVkeys::Reader {
public:
  typedef PlatformVkeys Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getPlatId() const;

  inline bool hasT() const;
  inline  ::Trie::Reader getT() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PlatformVkeys::Builder {
public:
  typedef PlatformVkeys Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getPlatId();
  inline void setPlatId( ::uint32_t value);

  inline bool hasT();
  inline  ::Trie::Builder getT();
  inline void setT( ::Trie::Reader value);
  inline  ::Trie::Builder initT();
  inline void adoptT(::capnp::Orphan< ::Trie>&& value);
  inline ::capnp::Orphan< ::Trie> disownT();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PlatformVkeys::Pipeline {
public:
  typedef PlatformVkeys Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Trie::Pipeline getT();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vkey::Reader {
public:
  typedef Vkey Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPlatforms() const;
  inline  ::capnp::List< ::PlatformVkeys>::Reader getPlatforms() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vkey::Builder {
public:
  typedef Vkey Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPlatforms();
  inline  ::capnp::List< ::PlatformVkeys>::Builder getPlatforms();
  inline void setPlatforms( ::capnp::List< ::PlatformVkeys>::Reader value);
  inline  ::capnp::List< ::PlatformVkeys>::Builder initPlatforms(unsigned int size);
  inline void adoptPlatforms(::capnp::Orphan< ::capnp::List< ::PlatformVkeys>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::PlatformVkeys>> disownPlatforms();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vkey::Pipeline {
public:
  typedef Vkey Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::uint16_t String32::Reader::getLen() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t String32::Builder::getLen() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void String32::Builder::setLen( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool String32::Reader::hasC() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool String32::Builder::hasC() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t>::Reader String32::Reader::getC() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t>::Builder String32::Builder::getC() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void String32::Builder::setC( ::capnp::List< ::uint32_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void String32::Builder::setC(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t>::Builder String32::Builder::initC(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void String32::Builder::adoptC(
    ::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> String32::Builder::disownC() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t DirEntry::Reader::getName() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t DirEntry::Builder::getName() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void DirEntry::Builder::setName( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t DirEntry::Reader::getOffset() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t DirEntry::Builder::getOffset() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void DirEntry::Builder::setOffset( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t DirEntry::Reader::getLength() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t DirEntry::Builder::getLength() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void DirEntry::Builder::setLength( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t DirEntry::Reader::getVersion() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t DirEntry::Builder::getVersion() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void DirEntry::Builder::setVersion( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool Directory::Reader::hasEntries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Directory::Builder::hasEntries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::DirEntry>::Reader Directory::Reader::getEntries() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::DirEntry>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::DirEntry>::Builder Directory::Builder::getEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::DirEntry>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Directory::Builder::setEntries( ::capnp::List< ::DirEntry>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::DirEntry>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::DirEntry>::Builder Directory::Builder::initEntries(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::DirEntry>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Directory::Builder::adoptEntries(
    ::capnp::Orphan< ::capnp::List< ::DirEntry>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::DirEntry>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::DirEntry>> Directory::Builder::disownEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::DirEntry>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint8_t Trie::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Trie::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Trie::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Trie::Reader::getReserved() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Trie::Builder::getReserved() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Trie::Builder::setReserved( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t Trie::Reader::getNumEntries() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Trie::Builder::getNumEntries() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Trie::Builder::setNumEntries( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Trie::Reader::getResult() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Trie::Builder::getResult() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Trie::Builder::setResult( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline typename Trie::TrieData::Reader Trie::Reader::getTrieData() const {
  return typename Trie::TrieData::Reader(_reader);
}
inline typename Trie::TrieData::Builder Trie::Builder::getTrieData() {
  return typename Trie::TrieData::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Trie::TrieData::Pipeline Trie::Pipeline::getTrieData() {
  return typename Trie::TrieData::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Trie::TrieData::Builder Trie::Builder::initTrieData() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<4>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename Trie::TrieData::Builder(_builder);
}
inline  ::Trie::TrieData::Which Trie::TrieData::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline  ::Trie::TrieData::Which Trie::TrieData::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline bool Trie::TrieData::Reader::isOrdered() const {
  return which() == Trie::TrieData::ORDERED;
}
inline bool Trie::TrieData::Builder::isOrdered() {
  return which() == Trie::TrieData::ORDERED;
}
inline bool Trie::TrieData::Reader::hasOrdered() const {
  if (which() != Trie::TrieData::ORDERED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Trie::TrieData::Builder::hasOrdered() {
  if (which() != Trie::TrieData::ORDERED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::OrderedTrie>::Reader Trie::TrieData::Reader::getOrdered() const {
  KJ_IREQUIRE((which() == Trie::TrieData::ORDERED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OrderedTrie>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::OrderedTrie>::Builder Trie::TrieData::Builder::getOrdered() {
  KJ_IREQUIRE((which() == Trie::TrieData::ORDERED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OrderedTrie>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Trie::TrieData::Builder::setOrdered( ::capnp::List< ::OrderedTrie>::Reader value) {
  _builder.setDataField<Trie::TrieData::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Trie::TrieData::ORDERED);
  ::capnp::_::PointerHelpers< ::capnp::List< ::OrderedTrie>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::OrderedTrie>::Builder Trie::TrieData::Builder::initOrdered(unsigned int size) {
  _builder.setDataField<Trie::TrieData::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Trie::TrieData::ORDERED);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OrderedTrie>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Trie::TrieData::Builder::adoptOrdered(
    ::capnp::Orphan< ::capnp::List< ::OrderedTrie>>&& value) {
  _builder.setDataField<Trie::TrieData::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Trie::TrieData::ORDERED);
  ::capnp::_::PointerHelpers< ::capnp::List< ::OrderedTrie>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::OrderedTrie>> Trie::TrieData::Builder::disownOrdered() {
  KJ_IREQUIRE((which() == Trie::TrieData::ORDERED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OrderedTrie>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Trie::TrieData::Reader::isSegmented() const {
  return which() == Trie::TrieData::SEGMENTED;
}
inline bool Trie::TrieData::Builder::isSegmented() {
  return which() == Trie::TrieData::SEGMENTED;
}
inline bool Trie::TrieData::Reader::hasSegmented() const {
  if (which() != Trie::TrieData::SEGMENTED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Trie::TrieData::Builder::hasSegmented() {
  if (which() != Trie::TrieData::SEGMENTED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::SegmentedTrie>::Reader Trie::TrieData::Reader::getSegmented() const {
  KJ_IREQUIRE((which() == Trie::TrieData::SEGMENTED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::SegmentedTrie>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::SegmentedTrie>::Builder Trie::TrieData::Builder::getSegmented() {
  KJ_IREQUIRE((which() == Trie::TrieData::SEGMENTED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::SegmentedTrie>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Trie::TrieData::Builder::setSegmented( ::capnp::List< ::SegmentedTrie>::Reader value) {
  _builder.setDataField<Trie::TrieData::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Trie::TrieData::SEGMENTED);
  ::capnp::_::PointerHelpers< ::capnp::List< ::SegmentedTrie>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::SegmentedTrie>::Builder Trie::TrieData::Builder::initSegmented(unsigned int size) {
  _builder.setDataField<Trie::TrieData::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Trie::TrieData::SEGMENTED);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::SegmentedTrie>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Trie::TrieData::Builder::adoptSegmented(
    ::capnp::Orphan< ::capnp::List< ::SegmentedTrie>>&& value) {
  _builder.setDataField<Trie::TrieData::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Trie::TrieData::SEGMENTED);
  ::capnp::_::PointerHelpers< ::capnp::List< ::SegmentedTrie>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::SegmentedTrie>> Trie::TrieData::Builder::disownSegmented() {
  KJ_IREQUIRE((which() == Trie::TrieData::SEGMENTED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::SegmentedTrie>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t OrderedTrie::Reader::getC() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t OrderedTrie::Builder::getC() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void OrderedTrie::Builder::setC( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t OrderedTrie::Reader::getO() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t OrderedTrie::Builder::getO() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void OrderedTrie::Builder::setO( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t SegmentedTrie::Reader::getC() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t SegmentedTrie::Builder::getC() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SegmentedTrie::Builder::setC( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool SegmentedTrie::Reader::hasOffsets() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SegmentedTrie::Builder::hasOffsets() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t>::Reader SegmentedTrie::Reader::getOffsets() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t>::Builder SegmentedTrie::Builder::getOffsets() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SegmentedTrie::Builder::setOffsets( ::capnp::List< ::uint32_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void SegmentedTrie::Builder::setOffsets(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t>::Builder SegmentedTrie::Builder::initOffsets(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void SegmentedTrie::Builder::adoptOffsets(
    ::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> SegmentedTrie::Builder::disownOffsets() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Rule::Reader::getError() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Rule::Builder::getError() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Rule::Builder::setError(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Rule::Reader::getOBefore() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Rule::Builder::getOBefore() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Rule::Builder::setOBefore( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Rule::Reader::getOAfter() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Rule::Builder::getOAfter() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Rule::Builder::setOAfter( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Rule::Reader::hasTo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Rule::Builder::hasTo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::String32::Reader Rule::Reader::getTo() const {
  return ::capnp::_::PointerHelpers< ::String32>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::String32::Builder Rule::Builder::getTo() {
  return ::capnp::_::PointerHelpers< ::String32>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::String32::Pipeline Rule::Pipeline::getTo() {
  return  ::String32::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Rule::Builder::setTo( ::String32::Reader value) {
  ::capnp::_::PointerHelpers< ::String32>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::String32::Builder Rule::Builder::initTo() {
  return ::capnp::_::PointerHelpers< ::String32>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Rule::Builder::adoptTo(
    ::capnp::Orphan< ::String32>&& value) {
  ::capnp::_::PointerHelpers< ::String32>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::String32> Rule::Builder::disownTo() {
  return ::capnp::_::PointerHelpers< ::String32>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Rule::Reader::hasBefore() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Rule::Builder::hasBefore() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::Trie::Reader Rule::Reader::getBefore() const {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Trie::Builder Rule::Builder::getBefore() {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Trie::Pipeline Rule::Pipeline::getBefore() {
  return  ::Trie::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Rule::Builder::setBefore( ::Trie::Reader value) {
  ::capnp::_::PointerHelpers< ::Trie>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::Trie::Builder Rule::Builder::initBefore() {
  return ::capnp::_::PointerHelpers< ::Trie>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Rule::Builder::adoptBefore(
    ::capnp::Orphan< ::Trie>&& value) {
  ::capnp::_::PointerHelpers< ::Trie>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Trie> Rule::Builder::disownBefore() {
  return ::capnp::_::PointerHelpers< ::Trie>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Rule::Reader::hasAfter() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Rule::Builder::hasAfter() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::Trie::Reader Rule::Reader::getAfter() const {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::Trie::Builder Rule::Builder::getAfter() {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Trie::Pipeline Rule::Pipeline::getAfter() {
  return  ::Trie::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Rule::Builder::setAfter( ::Trie::Reader value) {
  ::capnp::_::PointerHelpers< ::Trie>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::Trie::Builder Rule::Builder::initAfter() {
  return ::capnp::_::PointerHelpers< ::Trie>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Rule::Builder::adoptAfter(
    ::capnp::Orphan< ::Trie>&& value) {
  ::capnp::_::PointerHelpers< ::Trie>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Trie> Rule::Builder::disownAfter() {
  return ::capnp::_::PointerHelpers< ::Trie>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint16_t Trns::Reader::getSettings() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Trns::Builder::getSettings() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Trns::Builder::setSettings( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t Trns::Reader::getNumRules() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Trns::Builder::getNumRules() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Trns::Builder::setNumRules( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Trns::Reader::getOOutputs() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Trns::Builder::getOOutputs() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Trns::Builder::setOOutputs( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Trns::Reader::hasT() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Trns::Builder::hasT() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Trie::Reader Trns::Reader::getT() const {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Trie::Builder Trns::Builder::getT() {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Trie::Pipeline Trns::Pipeline::getT() {
  return  ::Trie::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Trns::Builder::setT( ::Trie::Reader value) {
  ::capnp::_::PointerHelpers< ::Trie>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Trie::Builder Trns::Builder::initT() {
  return ::capnp::_::PointerHelpers< ::Trie>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Trns::Builder::adoptT(
    ::capnp::Orphan< ::Trie>&& value) {
  ::capnp::_::PointerHelpers< ::Trie>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Trie> Trns::Builder::disownT() {
  return ::capnp::_::PointerHelpers< ::Trie>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Trns::Reader::hasOutputs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Trns::Builder::hasOutputs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Rule>::Reader Trns::Reader::getOutputs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Rule>::Builder Trns::Builder::getOutputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Trns::Builder::setOutputs( ::capnp::List< ::Rule>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Rule>::Builder Trns::Builder::initOutputs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Trns::Builder::adoptOutputs(
    ::capnp::Orphan< ::capnp::List< ::Rule>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Rule>> Trns::Builder::disownOutputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint16_t Trnf::Reader::getNumRules() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Trnf::Builder::getNumRules() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Trnf::Builder::setNumRules( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Trnf::Reader::getOOutputs() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Trnf::Builder::getOOutputs() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Trnf::Builder::setOOutputs( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Trnf::Reader::hasT() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Trnf::Builder::hasT() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Trie::Reader Trnf::Reader::getT() const {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Trie::Builder Trnf::Builder::getT() {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Trie::Pipeline Trnf::Pipeline::getT() {
  return  ::Trie::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Trnf::Builder::setT( ::Trie::Reader value) {
  ::capnp::_::PointerHelpers< ::Trie>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Trie::Builder Trnf::Builder::initT() {
  return ::capnp::_::PointerHelpers< ::Trie>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Trnf::Builder::adoptT(
    ::capnp::Orphan< ::Trie>&& value) {
  ::capnp::_::PointerHelpers< ::Trie>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Trie> Trnf::Builder::disownT() {
  return ::capnp::_::PointerHelpers< ::Trie>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Trnf::Reader::hasOutputs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Trnf::Builder::hasOutputs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Rule>::Reader Trnf::Reader::getOutputs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Rule>::Builder Trnf::Builder::getOutputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Trnf::Builder::setOutputs( ::capnp::List< ::Rule>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Rule>::Builder Trnf::Builder::initOutputs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Trnf::Builder::adoptOutputs(
    ::capnp::Orphan< ::capnp::List< ::Rule>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Rule>> Trnf::Builder::disownOutputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint16_t Trnb::Reader::getNumRules() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Trnb::Builder::getNumRules() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Trnb::Builder::setNumRules( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Trnb::Reader::getOOutputs() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Trnb::Builder::getOOutputs() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Trnb::Builder::setOOutputs( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Trnb::Reader::hasT() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Trnb::Builder::hasT() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Trie::Reader Trnb::Reader::getT() const {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Trie::Builder Trnb::Builder::getT() {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Trie::Pipeline Trnb::Pipeline::getT() {
  return  ::Trie::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Trnb::Builder::setT( ::Trie::Reader value) {
  ::capnp::_::PointerHelpers< ::Trie>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Trie::Builder Trnb::Builder::initT() {
  return ::capnp::_::PointerHelpers< ::Trie>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Trnb::Builder::adoptT(
    ::capnp::Orphan< ::Trie>&& value) {
  ::capnp::_::PointerHelpers< ::Trie>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Trie> Trnb::Builder::disownT() {
  return ::capnp::_::PointerHelpers< ::Trie>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Trnb::Reader::hasOutputs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Trnb::Builder::hasOutputs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Rule>::Reader Trnb::Reader::getOutputs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Rule>::Builder Trnb::Builder::getOutputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Trnb::Builder::setOutputs( ::capnp::List< ::Rule>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Rule>::Builder Trnb::Builder::initOutputs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Trnb::Builder::adoptOutputs(
    ::capnp::Orphan< ::capnp::List< ::Rule>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Rule>> Trnb::Builder::disownOutputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Rule>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool OrderRule::Reader::getError() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool OrderRule::Builder::getError() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void OrderRule::Builder::setError(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t OrderRule::Reader::getILen() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t OrderRule::Builder::getILen() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void OrderRule::Builder::setILen( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t OrderRule::Reader::getOAfter() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t OrderRule::Builder::getOAfter() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void OrderRule::Builder::setOAfter( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool OrderRule::Reader::hasOrder() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool OrderRule::Builder::hasOrder() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::OrderRule::Info>::Reader OrderRule::Reader::getOrder() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OrderRule::Info>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::OrderRule::Info>::Builder OrderRule::Builder::getOrder() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OrderRule::Info>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void OrderRule::Builder::setOrder( ::capnp::List< ::OrderRule::Info>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::OrderRule::Info>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::OrderRule::Info>::Builder OrderRule::Builder::initOrder(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OrderRule::Info>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void OrderRule::Builder::adoptOrder(
    ::capnp::Orphan< ::capnp::List< ::OrderRule::Info>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::OrderRule::Info>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::OrderRule::Info>> OrderRule::Builder::disownOrder() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OrderRule::Info>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool OrderRule::Reader::hasBefore() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool OrderRule::Builder::hasBefore() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::Trie::Reader OrderRule::Reader::getBefore() const {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Trie::Builder OrderRule::Builder::getBefore() {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Trie::Pipeline OrderRule::Pipeline::getBefore() {
  return  ::Trie::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void OrderRule::Builder::setBefore( ::Trie::Reader value) {
  ::capnp::_::PointerHelpers< ::Trie>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::Trie::Builder OrderRule::Builder::initBefore() {
  return ::capnp::_::PointerHelpers< ::Trie>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void OrderRule::Builder::adoptBefore(
    ::capnp::Orphan< ::Trie>&& value) {
  ::capnp::_::PointerHelpers< ::Trie>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Trie> OrderRule::Builder::disownBefore() {
  return ::capnp::_::PointerHelpers< ::Trie>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool OrderRule::Reader::hasAfter() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool OrderRule::Builder::hasAfter() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::Trie::Reader OrderRule::Reader::getAfter() const {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::Trie::Builder OrderRule::Builder::getAfter() {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Trie::Pipeline OrderRule::Pipeline::getAfter() {
  return  ::Trie::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void OrderRule::Builder::setAfter( ::Trie::Reader value) {
  ::capnp::_::PointerHelpers< ::Trie>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::Trie::Builder OrderRule::Builder::initAfter() {
  return ::capnp::_::PointerHelpers< ::Trie>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void OrderRule::Builder::adoptAfter(
    ::capnp::Orphan< ::Trie>&& value) {
  ::capnp::_::PointerHelpers< ::Trie>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Trie> OrderRule::Builder::disownAfter() {
  return ::capnp::_::PointerHelpers< ::Trie>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool OrderRule::Info::Reader::getPrebase() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool OrderRule::Info::Builder::getPrebase() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void OrderRule::Info::Builder::setPrebase(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool OrderRule::Info::Reader::getTertiaryBase() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool OrderRule::Info::Builder::getTertiaryBase() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void OrderRule::Info::Builder::setTertiaryBase(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int8_t OrderRule::Info::Reader::getOrder() const {
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int8_t OrderRule::Info::Builder::getOrder() {
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void OrderRule::Info::Builder::setOrder( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t Trnr::Reader::getNumRules() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Trnr::Builder::getNumRules() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Trnr::Builder::setNumRules( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Trnr::Reader::getOOutputs() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Trnr::Builder::getOOutputs() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Trnr::Builder::setOOutputs( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Trnr::Reader::hasT() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Trnr::Builder::hasT() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Trie::Reader Trnr::Reader::getT() const {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Trie::Builder Trnr::Builder::getT() {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Trie::Pipeline Trnr::Pipeline::getT() {
  return  ::Trie::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Trnr::Builder::setT( ::Trie::Reader value) {
  ::capnp::_::PointerHelpers< ::Trie>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Trie::Builder Trnr::Builder::initT() {
  return ::capnp::_::PointerHelpers< ::Trie>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Trnr::Builder::adoptT(
    ::capnp::Orphan< ::Trie>&& value) {
  ::capnp::_::PointerHelpers< ::Trie>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Trie> Trnr::Builder::disownT() {
  return ::capnp::_::PointerHelpers< ::Trie>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Trnr::Reader::hasOutputs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Trnr::Builder::hasOutputs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::OrderRule>::Reader Trnr::Reader::getOutputs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OrderRule>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::OrderRule>::Builder Trnr::Builder::getOutputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OrderRule>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Trnr::Builder::setOutputs( ::capnp::List< ::OrderRule>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::OrderRule>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::OrderRule>::Builder Trnr::Builder::initOutputs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OrderRule>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Trnr::Builder::adoptOutputs(
    ::capnp::Orphan< ::capnp::List< ::OrderRule>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::OrderRule>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::OrderRule>> Trnr::Builder::disownOutputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OrderRule>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint8_t KeyMap::Reader::getEModLen() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t KeyMap::Builder::getEModLen() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void KeyMap::Builder::setEModLen( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t KeyMap::Reader::getModifiers() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t KeyMap::Builder::getModifiers() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void KeyMap::Builder::setModifiers( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t KeyMap::Reader::getOEntries() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t KeyMap::Builder::getOEntries() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void KeyMap::Builder::setOEntries( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t KeyMap::Reader::getEntriesLen() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t KeyMap::Builder::getEntriesLen() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void KeyMap::Builder::setEntriesLen( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool KeyMap::Reader::hasEModifiers() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool KeyMap::Builder::hasEModifiers() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader KeyMap::Reader::getEModifiers() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder KeyMap::Builder::getEModifiers() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void KeyMap::Builder::setEModifiers( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder KeyMap::Builder::initEModifiers(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void KeyMap::Builder::adoptEModifiers(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> KeyMap::Builder::disownEModifiers() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool KeyMap::Reader::hasT() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool KeyMap::Builder::hasT() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::Trie::Reader KeyMap::Reader::getT() const {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Trie::Builder KeyMap::Builder::getT() {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Trie::Pipeline KeyMap::Pipeline::getT() {
  return  ::Trie::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void KeyMap::Builder::setT( ::Trie::Reader value) {
  ::capnp::_::PointerHelpers< ::Trie>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::Trie::Builder KeyMap::Builder::initT() {
  return ::capnp::_::PointerHelpers< ::Trie>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void KeyMap::Builder::adoptT(
    ::capnp::Orphan< ::Trie>&& value) {
  ::capnp::_::PointerHelpers< ::Trie>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Trie> KeyMap::Builder::disownT() {
  return ::capnp::_::PointerHelpers< ::Trie>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool KeyMap::Reader::hasEntries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool KeyMap::Builder::hasEntries() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::KmapEntry>::Reader KeyMap::Reader::getEntries() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::KmapEntry>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::KmapEntry>::Builder KeyMap::Builder::getEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::KmapEntry>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void KeyMap::Builder::setEntries( ::capnp::List< ::KmapEntry>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::KmapEntry>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::KmapEntry>::Builder KeyMap::Builder::initEntries(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::KmapEntry>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void KeyMap::Builder::adoptEntries(
    ::capnp::Orphan< ::capnp::List< ::KmapEntry>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::KmapEntry>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::KmapEntry>> KeyMap::Builder::disownEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::KmapEntry>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool KmapEntry::Reader::hasTo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool KmapEntry::Builder::hasTo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::String32::Reader KmapEntry::Reader::getTo() const {
  return ::capnp::_::PointerHelpers< ::String32>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::String32::Builder KmapEntry::Builder::getTo() {
  return ::capnp::_::PointerHelpers< ::String32>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::String32::Pipeline KmapEntry::Pipeline::getTo() {
  return  ::String32::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void KmapEntry::Builder::setTo( ::String32::Reader value) {
  ::capnp::_::PointerHelpers< ::String32>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::String32::Builder KmapEntry::Builder::initTo() {
  return ::capnp::_::PointerHelpers< ::String32>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void KmapEntry::Builder::adoptTo(
    ::capnp::Orphan< ::String32>&& value) {
  ::capnp::_::PointerHelpers< ::String32>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::String32> KmapEntry::Builder::disownTo() {
  return ::capnp::_::PointerHelpers< ::String32>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint8_t KmapEntry::Reader::getMultiLen() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t KmapEntry::Builder::getMultiLen() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void KmapEntry::Builder::setMultiLen( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t KmapEntry::Reader::getOLong() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t KmapEntry::Builder::getOLong() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void KmapEntry::Builder::setOLong( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t KmapEntry::Reader::getLongLen() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t KmapEntry::Builder::getLongLen() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void KmapEntry::Builder::setLongLen( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t KmapEntry::Reader::getOFlick() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t KmapEntry::Builder::getOFlick() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void KmapEntry::Builder::setOFlick( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool KmapEntry::Reader::hasMultiTap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool KmapEntry::Builder::hasMultiTap() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::String32>::Reader KmapEntry::Reader::getMultiTap() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::String32>::Builder KmapEntry::Builder::getMultiTap() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void KmapEntry::Builder::setMultiTap( ::capnp::List< ::String32>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::String32>::Builder KmapEntry::Builder::initMultiTap(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void KmapEntry::Builder::adoptMultiTap(
    ::capnp::Orphan< ::capnp::List< ::String32>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::String32>> KmapEntry::Builder::disownMultiTap() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool KmapEntry::Reader::hasLongPress() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool KmapEntry::Builder::hasLongPress() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::String32>::Reader KmapEntry::Reader::getLongPress() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::String32>::Builder KmapEntry::Builder::getLongPress() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void KmapEntry::Builder::setLongPress( ::capnp::List< ::String32>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::String32>::Builder KmapEntry::Builder::initLongPress(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void KmapEntry::Builder::adoptLongPress(
    ::capnp::Orphan< ::capnp::List< ::String32>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::String32>> KmapEntry::Builder::disownLongPress() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool KmapEntry::Reader::hasFlicks() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool KmapEntry::Builder::hasFlicks() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::String32>::Reader KmapEntry::Reader::getFlicks() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::String32>::Builder KmapEntry::Builder::getFlicks() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void KmapEntry::Builder::setFlicks( ::capnp::List< ::String32>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::String32>::Builder KmapEntry::Builder::initFlicks(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void KmapEntry::Builder::adoptFlicks(
    ::capnp::Orphan< ::capnp::List< ::String32>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::String32>> KmapEntry::Builder::disownFlicks() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Kmap::Reader::hasMaps() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Kmap::Builder::hasMaps() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::KeyMap>::Reader Kmap::Reader::getMaps() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::KeyMap>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::KeyMap>::Builder Kmap::Builder::getMaps() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::KeyMap>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Kmap::Builder::setMaps( ::capnp::List< ::KeyMap>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::KeyMap>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::KeyMap>::Builder Kmap::Builder::initMaps(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::KeyMap>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Kmap::Builder::adoptMaps(
    ::capnp::Orphan< ::capnp::List< ::KeyMap>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::KeyMap>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::KeyMap>> Kmap::Builder::disownMaps() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::KeyMap>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t LayerKey::Reader::getIso() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t LayerKey::Builder::getIso() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LayerKey::Builder::setIso( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t LayerKey::Reader::getOHint() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t LayerKey::Builder::getOHint() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LayerKey::Builder::setOHint( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool LayerKey::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LayerKey::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::String32::Reader LayerKey::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::String32>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::String32::Builder LayerKey::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::String32>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::String32::Pipeline LayerKey::Pipeline::getCap() {
  return  ::String32::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void LayerKey::Builder::setCap( ::String32::Reader value) {
  ::capnp::_::PointerHelpers< ::String32>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::String32::Builder LayerKey::Builder::initCap() {
  return ::capnp::_::PointerHelpers< ::String32>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LayerKey::Builder::adoptCap(
    ::capnp::Orphan< ::String32>&& value) {
  ::capnp::_::PointerHelpers< ::String32>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::String32> LayerKey::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::String32>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LayerKey::Reader::hasHint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool LayerKey::Builder::hasHint() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::String32::Reader LayerKey::Reader::getHint() const {
  return ::capnp::_::PointerHelpers< ::String32>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::String32::Builder LayerKey::Builder::getHint() {
  return ::capnp::_::PointerHelpers< ::String32>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::String32::Pipeline LayerKey::Pipeline::getHint() {
  return  ::String32::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void LayerKey::Builder::setHint( ::String32::Reader value) {
  ::capnp::_::PointerHelpers< ::String32>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::String32::Builder LayerKey::Builder::initHint() {
  return ::capnp::_::PointerHelpers< ::String32>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void LayerKey::Builder::adoptHint(
    ::capnp::Orphan< ::String32>&& value) {
  ::capnp::_::PointerHelpers< ::String32>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::String32> LayerKey::Builder::disownHint() {
  return ::capnp::_::PointerHelpers< ::String32>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool LayerRow::Reader::hasKeys() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LayerRow::Builder::hasKeys() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::LayerKey>::Reader LayerRow::Reader::getKeys() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LayerKey>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::LayerKey>::Builder LayerRow::Builder::getKeys() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LayerKey>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LayerRow::Builder::setKeys( ::capnp::List< ::LayerKey>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LayerKey>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::LayerKey>::Builder LayerRow::Builder::initKeys(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LayerKey>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void LayerRow::Builder::adoptKeys(
    ::capnp::Orphan< ::capnp::List< ::LayerKey>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LayerKey>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::LayerKey>> LayerRow::Builder::disownKeys() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LayerKey>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t LayerSwitch::Reader::getOLayer() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t LayerSwitch::Builder::getOLayer() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LayerSwitch::Builder::setOLayer( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t LayerSwitch::Reader::getIso() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t LayerSwitch::Builder::getIso() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LayerSwitch::Builder::setIso( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool LayerSwitch::Reader::hasLayer() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LayerSwitch::Builder::hasLayer() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::String32::Reader LayerSwitch::Reader::getLayer() const {
  return ::capnp::_::PointerHelpers< ::String32>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::String32::Builder LayerSwitch::Builder::getLayer() {
  return ::capnp::_::PointerHelpers< ::String32>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::String32::Pipeline LayerSwitch::Pipeline::getLayer() {
  return  ::String32::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void LayerSwitch::Builder::setLayer( ::String32::Reader value) {
  ::capnp::_::PointerHelpers< ::String32>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::String32::Builder LayerSwitch::Builder::initLayer() {
  return ::capnp::_::PointerHelpers< ::String32>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LayerSwitch::Builder::adoptLayer(
    ::capnp::Orphan< ::String32>&& value) {
  ::capnp::_::PointerHelpers< ::String32>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::String32> LayerSwitch::Builder::disownLayer() {
  return ::capnp::_::PointerHelpers< ::String32>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint16_t Layer::Reader::getModifier() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Layer::Builder::getModifier() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Layer::Builder::setModifier( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Layer::Reader::getRowsLen() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Layer::Builder::getRowsLen() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Layer::Builder::setRowsLen( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Layer::Reader::getSwitchesLen() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Layer::Builder::getSwitchesLen() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Layer::Builder::setSwitchesLen( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Layer::Reader::getVkeysLen() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Layer::Builder::getVkeysLen() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Layer::Builder::setVkeysLen( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Layer::Reader::getOSwitches() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Layer::Builder::getOSwitches() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Layer::Builder::setOSwitches( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Layer::Reader::hasRows() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Layer::Builder::hasRows() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::LayerRow>::Reader Layer::Reader::getRows() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LayerRow>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::LayerRow>::Builder Layer::Builder::getRows() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LayerRow>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Layer::Builder::setRows( ::capnp::List< ::LayerRow>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LayerRow>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::LayerRow>::Builder Layer::Builder::initRows(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LayerRow>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Layer::Builder::adoptRows(
    ::capnp::Orphan< ::capnp::List< ::LayerRow>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LayerRow>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::LayerRow>> Layer::Builder::disownRows() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LayerRow>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Layer::Reader::hasSwitches() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Layer::Builder::hasSwitches() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::LayerSwitch>::Reader Layer::Reader::getSwitches() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LayerSwitch>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::LayerSwitch>::Builder Layer::Builder::getSwitches() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LayerSwitch>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Layer::Builder::setSwitches( ::capnp::List< ::LayerSwitch>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LayerSwitch>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::LayerSwitch>::Builder Layer::Builder::initSwitches(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LayerSwitch>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Layer::Builder::adoptSwitches(
    ::capnp::Orphan< ::capnp::List< ::LayerSwitch>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LayerSwitch>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::LayerSwitch>> Layer::Builder::disownSwitches() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LayerSwitch>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Layr::Reader::hasLayers() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Layr::Builder::hasLayers() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Layer>::Reader Layr::Reader::getLayers() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Layer>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Layer>::Builder Layr::Builder::getLayers() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Layer>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Layr::Builder::setLayers( ::capnp::List< ::Layer>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Layer>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Layer>::Builder Layr::Builder::initLayers(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Layer>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Layr::Builder::adoptLayers(
    ::capnp::Orphan< ::capnp::List< ::Layer>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Layer>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Layer>> Layr::Builder::disownLayers() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Layer>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Name::Reader::hasNames() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Name::Builder::hasNames() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::String32>::Reader Name::Reader::getNames() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::String32>::Builder Name::Builder::getNames() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Name::Builder::setNames( ::capnp::List< ::String32>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::String32>::Builder Name::Builder::initNames(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Name::Builder::adoptNames(
    ::capnp::Orphan< ::capnp::List< ::String32>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::String32>> Name::Builder::disownNames() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::String32>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Head::Reader::hasVer() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Head::Builder::hasVer() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::String32::Reader Head::Reader::getVer() const {
  return ::capnp::_::PointerHelpers< ::String32>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::String32::Builder Head::Builder::getVer() {
  return ::capnp::_::PointerHelpers< ::String32>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::String32::Pipeline Head::Pipeline::getVer() {
  return  ::String32::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Head::Builder::setVer( ::String32::Reader value) {
  ::capnp::_::PointerHelpers< ::String32>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::String32::Builder Head::Builder::initVer() {
  return ::capnp::_::PointerHelpers< ::String32>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Head::Builder::adoptVer(
    ::capnp::Orphan< ::String32>&& value) {
  ::capnp::_::PointerHelpers< ::String32>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::String32> Head::Builder::disownVer() {
  return ::capnp::_::PointerHelpers< ::String32>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint16_t VkeyEntry::Reader::getVkeyCode() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t VkeyEntry::Builder::getVkeyCode() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void VkeyEntry::Builder::setVkeyCode( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t VkeyEntry::Reader::getModifiers() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t VkeyEntry::Builder::getModifiers() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void VkeyEntry::Builder::setModifiers( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t PlatformVkeys::Reader::getPlatId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t PlatformVkeys::Builder::getPlatId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PlatformVkeys::Builder::setPlatId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool PlatformVkeys::Reader::hasT() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PlatformVkeys::Builder::hasT() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Trie::Reader PlatformVkeys::Reader::getT() const {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Trie::Builder PlatformVkeys::Builder::getT() {
  return ::capnp::_::PointerHelpers< ::Trie>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Trie::Pipeline PlatformVkeys::Pipeline::getT() {
  return  ::Trie::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PlatformVkeys::Builder::setT( ::Trie::Reader value) {
  ::capnp::_::PointerHelpers< ::Trie>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Trie::Builder PlatformVkeys::Builder::initT() {
  return ::capnp::_::PointerHelpers< ::Trie>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PlatformVkeys::Builder::adoptT(
    ::capnp::Orphan< ::Trie>&& value) {
  ::capnp::_::PointerHelpers< ::Trie>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Trie> PlatformVkeys::Builder::disownT() {
  return ::capnp::_::PointerHelpers< ::Trie>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Vkey::Reader::hasPlatforms() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Vkey::Builder::hasPlatforms() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::PlatformVkeys>::Reader Vkey::Reader::getPlatforms() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PlatformVkeys>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::PlatformVkeys>::Builder Vkey::Builder::getPlatforms() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PlatformVkeys>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Vkey::Builder::setPlatforms( ::capnp::List< ::PlatformVkeys>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::PlatformVkeys>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::PlatformVkeys>::Builder Vkey::Builder::initPlatforms(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PlatformVkeys>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Vkey::Builder::adoptPlatforms(
    ::capnp::Orphan< ::capnp::List< ::PlatformVkeys>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::PlatformVkeys>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::PlatformVkeys>> Vkey::Builder::disownPlatforms() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PlatformVkeys>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}


#endif  // CAPNP_INCLUDED_e0c33bb359ddae62_
